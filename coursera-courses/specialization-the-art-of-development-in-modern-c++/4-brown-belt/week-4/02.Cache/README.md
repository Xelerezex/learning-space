## Cache

В этой задаче мы поработаем с ```shared_ptr``` в многопоточной среде.

Нужно будет реализовать кэш бэкенда электронной библиотеки. На диске есть множество книг — архивированных
текстовых файлов. Пользователь запрашивает книгу с заданным названием. Надо её считать, распаковать и
вернуть. Чаще всего пользователи запрашивают одни и те же книги, поэтому их хочется кэшировать. При этом
запросы приходят в несколько потоков.

Для доступа к книгам используется интерфейс ```ICache```, объявленный в файле **Common.h**. У него всего
один метод ```GetBook()```, который возвращает ```shared_ptr``` на книгу (используется синоним ```BookPtr```).
Реализация этого метода должна обеспечить правильное кэширование.

Книга представлена интерфейсом ```IBook```. Два его метода ```GetName()``` и ```GetContent()``` позволяют
получить название и текст книги соответственно.

Наконец, считывание и распаковка книги делаются с помощью интерфейса ```IBooksUnpacker```. Его метод
```UnpackBook()``` по переданному названию книги возвращает распакованную книгу как объект ```IBook```.

Для создания объекта ```ICache``` используется функция ```MakeCache()```, которую вам необходимо
реализовать. Она принимает объект ```IBooksUnpacker```, а также объект ```ICache::Settings``` - настройки
кэша. В нашей задаче настройки содержат всего один параметр ```max_memory``` — максимальный суммарный размер
всех книг в кэше в байтах, — но в реальности их может быть больше. Именно поэтому мы оформили настройки в
виде структуры. Размером книги считается размер её текста в байтах.

Кэширование производится методом вытеснения давно неиспользуемых элементов ```(Least Recently Used, LRU)```.
Каждый элемент кэша имеет ранг. При вызове метода ```GetBook()```, если книга с таким названием уже есть в
кэше, её ранг поднимается до максимального (строго больше, чем у всех остальных). Если такой книги нет в кэше,
то она добавляется в кэш, и её ранг, опять же, выставляется в максимальный. При этом, если общий размер книг
превышает ограничение ```max_memory```, из кэша удаляются книги с наименьшим рангом, пока это необходимо.
Возможно, пока он полностью не будет опустошён. Если же размер запрошенной книги уже превышает ```max_memory```,
то после вызова метода кэш остаётся пустым, то есть книга в него не добавляется.

Метод ```GetBook()``` может вызываться одновременно из нескольких потоков, поэтому необходимо обеспечить ему
безопасность работы в таких условиях.

Используемые на практике реализации ```LRU``` кэшей позволяют искать элементы по ключу и удалять давно
неиспользуемые элементы за константное время. В данной задаче этого не требуется. Искать давно неиспользуемые
элементы можно перебором всех имеющихся.

Помимо **Common.h** вам даны два файла: **main.cpp** и **Solution.cpp**. Первый содержит неполный набор
тестов для функции ```MakeCache```, второй — заготовку решения. Реализуйте функцию ```MakeCache``` в файле
**Solution.cpp** и сдайте этот файл в тестирующую систему.

## Заготовка задачи и необходимые файлы:

>   [Solution.cpp](https://d3c33hcgiwev3.cloudfront.net/rbqRGP7eEeilxxL_ZeRz_A_ae11d840fede11e8a68b1b5a9f1726a7_Solution.cpp?Expires=1649894400&Signature=BuoZMT7pg9r-cyJpZu3bseR3Vk6X~TSf64ffn-6fCK6mfxGcgVRtZlxXnsxBRR267LcXt9ToCrkjgp7gFWbB3qm9E4Y5Bai2mDYp9WBb1d53owD41NH3Qqf~EP7-213zvWSVS7-RwVuBw3h26tcnZsbvNTM53nNuV9kXEj4kMC4_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

>   [Common.h](https://d3c33hcgiwev3.cloudfront.net/rbsGJf7eEeiAgQrXx6bp4g_ae102a90fede11e8baa633ec03f95dff_Common.h?Expires=1649894400&Signature=PRaxDbsYy9rIn~cVyKFkuvvkyerC2dsxOpzdO2Arx28tFczAosa~gHnxlAP-2v~Gs3nzUu6mqMhuP9EpuUpQajeYfJblj3zT4l3XWbxVVy3Vq7Z8LcmAs6EeIRV9qi0y~-68PH3AjYslvsMcNpJtgMsop3Lz7t9dqvk~Khm2-ZM_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

>   [main.cpp](https://d3c33hcgiwev3.cloudfront.net/9EatJAISEemlxxL_ZeRz_A_f4c997f0021211e9a289791da6d76b4f_main.cpp?Expires=1649894400&Signature=TEPaJjn1DpCG3Nbgl~2nFYJ6sWmlySTWgCwfWXr-FAFnPdeSIyaq99j3GDO8S1-Viebkz9DX5WoSCKEeb6F3CE~0It94icIzah8awyi820jleixaod~HFeqZOUfGbrYqWjkUPdvClMSQx-NQcEefzBYW5PlpkMuDysXtCV4L7Ec_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

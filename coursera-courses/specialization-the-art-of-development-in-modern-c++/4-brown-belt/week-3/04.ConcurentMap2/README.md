## Concurrent Map 2

### Замечание

Мы уже добавили константность в шаблон ```Synchronized```, который разработали в «Красном поясе по С++». На
очереди другой шаблон из модуля «Базовая многопоточность» — ```ConcurrentMap```. С момента, как мы написали
его в «Красном поясе по С++», мы изучили две важные темы — ```unordered-контейнеры``` и ```mutable-поля```.
И теперь мы применим эти знания, чтобы приблизить ConcurrentMap к его промышленной реализации.

Эта задача — продолжение задачи «```ConcurrentMap```» из «Красного пояса по C++». Ниже приведено её полное
условие с необходимыми изменениями. Так что если вы не проходили «Красный пояс», можете просто решать эту
задачу с нуля. Дополнительные требования по сравнению с «Красным поясом по С++»:

-   внутри класса надо использовать ```unordered-контейнер``` вместо ```std::map```

-   необходимо поддержать ключи произвольного типа, а не только целочисленные

-   нужно добавить константные методы ```Has``` и ```At```

-   нужно сделать метод ```BuildOrdinaryMap``` константным

### Условие

Давайте представим, что у нас есть ```unordered_map```, к которому обращаются несколько потоков. Чтобы
синхронизировать доступ к нему, мы можем каждое обращение к этому ```unordered_map'у``` защитить мьютексом
(например, завернув наш ```unordered_map``` в шаблон ```Synchronized```). Теперь давайте представим, что у
нас есть ```Synchronized<unordered_map<int, int>>```, в котором хранятся все ключи от *1* до *10000*.
Интуитивно кажется, что когда из одного потока мы обращаемся к ключу *10*, а из другого — например, к ключу *6712*,
то нет смысла защищать эти обращения одним и тем же мьютексом. Это отдельные области памяти, а внутреннюю
структуру словаря мы никак не изменяем. При этом, если мы будем обращаться к ключу *6712* одновременно из
нескольких потоков, то синхронизация, несомненно, понадобится.

Отсюда возникает идея — разбить наш словарь на несколько подсловарей с непересекающимся набором ключей и
защитить каждый из них отдельным мьютексом. Тогда при обращении разных потоков к разным ключам они нечасто будут
попадать в один и тот же подсловарь, а значит, смогут параллельно его обрабатывать. Эту идею вам предстоит
реализовать в этой задаче. Вам надо написать шаблон класса ```ConcurrentMap``` вот с таким интерфейсом:

```cpp
template <typename K, typename V, typename Hash = std::hash<K>>
class ConcurrentMap {
    public:
        using MapType = unordered_map<K, V, Hash>;

        struct WriteAccess {
            V& ref_to_value;
        };

        struct ReadAccess {
            const V& ref_to_value;
        };

        explicit ConcurrentMap(size_t bucket_count);

        WriteAccess operator[](const K& key);
        ReadAccess At(const K& key) const;

        bool Has(const K& key) const;

        MapType BuildOrdinaryMap() const;

    private:
        Hash hasher;
};
```


-   Конструктор класса ```ConcurrentMap<K, V>``` принимает количество подсловарей, на которые надо разбить всё
    пространство ключей.

-   ```operator[]``` должен вести себя так же, как аналогичный оператор у ```unordered_map``` — если ключ ```key```
    присутствует в словаре, он должен возвращать объект класса ```WriteAccess```, содержащий ссылку на соответствующее
    ему значение; если же ```key``` отсутствует в словаре, в него надо добавить пару ```(key, V())``` и вернуть
    объект класса ```WriteAccess```, содержащий ссылку на только что добавленное значение.

-   Метод ```At``` должен вести себя так же, как аналогичный метод у ```unordered_map``` — если ключ ```key```
    присутствует в словаре, он должен возвращать объект класса ```ReadAccess```, содержащий константную ссылку
    на соответствующее ему значение; если же ```key``` отсутствует в словаре, метод ```At``` должен выбросить
    исключение ```std::out_of_range```.

-   Структуры ```WriteAccess``` и ```ReadAccess``` должны вести себя так же, как и в шаблоне ```Synchronized```,
    — предоставлять ссылку на значение словаря и обеспечивать синхронизацию доступа к нему.

-   Метод ```BuildOrdinaryMap``` должен сливать вместе части словаря и возвращать весь словарь целиком. При этом
    он должен быть потокобезопасным, то есть корректно работать, когда другие потоки выполняют операции
    с ```ConcurrentMap```. В отличие от задачи из «Красного пояса по С++» в этой задаче метод ```BuildOrdinaryMap```
    сделан константным.

-   Метод ```Has``` должен потокобезопасно проверять, что переданный ключ присутствует в словаре.

-   Третий шаблонный параметр — ```Hash``` — используется для хеширования ключей типа ```K```. Его интерфейс
    аналогичен ```std::hash``` — это класс, который имеет константный ```size_t operator()(const K& key) const```.

### Заготовка решения задачи

>   [concurrent_map_2.cpp](https://d3c33hcgiwev3.cloudfront.net/UGvpyAnpEemP8Qpm209XvA_50c330b009e911e99390b5c03f9a3731_concurrent_map_2.cpp?Expires=1647388800&Signature=BXgaBw8Jx8LKuwV1LfyA53MeQS5N1mupXp7~VRDaOuGlcxtCch-tegdkBfkalUVksBUOngYnVY82KA~DDjTkc0rMA-9yScaspMsvKTM8tUooWJrS1a-xVgYJ75vFfyt7yCPVXcuxz~qco1zTAi56fo8eWHHPkuIytgy-JpdUXXY_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Syncronized2

### Замечание

Эта задача — продолжение задачи «Шаблон Synchronized» из «Красного пояса по C++». Ниже приведено её полное
условие с необходимыми дополнениями. Так что если вы не проходили «Красный пояс», можете просто решать эту задачу
с нуля.

Дополнительные требования по сравнению с «Красным поясом по С++»:

-   нужно добавить константный метод GetAccess, который возвращает объект, содержащий константную ссылку на
    хранимый объект

### Условие

Как известно, отсутствие синхронизации доступа нескольких потоков к одним и тем же данным может фатально сказаться
на работе программы. Поэтому очень важно не забывать захватывать мьютекс при обращении к разделяемым данным.
Но если у нас есть большой проект, в котором доступ к общим данным осуществляется из большого количества мест в
коде, то не так уж и трудно забыть сделать это, внося очередные правки.

Чтобы защититься от такой забывчивости, можно написать специальную обёртку над данными, которая будет предоставлять
к ним доступ только под мьютексом. В этой задаче вам надо разработать такую обёртку — шаблон класса
```Synchronized``` вот с таким интерфейсом:

```cpp
template <typename T>
class Synchronized {
    public:
        explicit Synchronized(T initial = T());

        Access1 GetAccess();
        Access2 GetAccess() const;
    private:
        T value;
};
```

Типы ```Access1``` и ```Access2``` должны быть структурами, в которых есть поля
```T& ref_to_value``` и ```const T& ref_to_value``` соответственно. В обоих случаях поле ```ref_to_value```
должно ссылаться на поле ```value``` класса ```Synchronized<T>```. Кроме того, объекты классов ```Access1``` и
```Access2``` должны вести себя аналогично классу ```lock_guard<mutex>```: захватывать мьютекс в своём конструкторе
и освобождать в деструкторе.

Пример:

```cpp
Synchronized<int> s_int;
{
    auto access = s_int.GetAccess();
    // Критическая секция начинается отсюда и продолжается до конца блока
    access.ref_to_value = 5;
}
ASSERT_EQUAL(s_int.GetAccess().ref_to_value, 5);
```

Вам можно (и даже нужно) добавлять необходимые поля в классы ```Access1```, ```Access2``` и шаблон
```Synchronized```. Более подробные примеры использования шаблона ```Synchronized``` смотрите в заготовке решения.

Как видите, единственный способ получить доступ к полю ```value``` класса ```Synchronized<T>``` — это обратиться
к полю ```ref_to_value``` классов ```Access1``` и ```Access2```, которые гарантируют, что этот доступ
осуществляется под мьютексом. Таким образом, если разделяемые данные обернуть в шаблон ```Synchronized```, вы
никогда не забудете захватить мьютекс при обращении к ним.

### Примечание

Проверяющий код никак не закладывается на имена типов, возвращаемых методами ```GetAccess```, поэтому вы можете
назвать их не ```Access1``` и ```Access2```, а как-то более осмысленно.

>   [synchronized_2.cpp](https://d3c33hcgiwev3.cloudfront.net/tedfaPY8EeilxxL_ZeRz_A_b66e4230f63c11e88865336dfe4492c5_synchronized_2.cpp?Expires=1647388800&Signature=bLcbmcIjhyBrKd2ZoDEnAQyypqrc3oK59k0k2LHD-ZOu5iK-xZ4qBzq9tD5DS6QmruVhLfMuhSuNj2EV5k-xjmCOQSh-gIXK8wW7BtLmbqLOGEE881pEwK-V~Q3ZO5jI1MwYTlhFkvKfvwTlaavwfr3NpM9koiDDHtg3WJcFAAI_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

## Pipeline

### Введение

Многие программы создаются для пакетной обработки большого числа однородных записей. Часто при этом обработка
этих записей может быть разделена на логически самостоятельные этапы, это упрощает совместную разработку новых
фич и позволяет легко комбинировать эти этапы в новые конфигурации. Такую обработку можно мысленно вообразить
себе как поток объектов, идущих по конвейеру от одного обработчика к другому. В этой задаче вам предстоит
закончить реализацию такого конвейера.

Основная идея конвейера в том, чтобы использовать функции, "поглощающие" объекты и вызывающие друг друга:

```cpp
void ConsumeObject(unique_ptr<SomeObject> obj)
{
    // обработка
    ConsumeObject2(move(obj));  // теряем владение объектом
}
```

Возможен вариант архитектуры с ```shared_ptr```, но обычно достаточно ```unique_ptr```, и он в этой ситуации
обладает преимуществами:

-   уменьшает накладные расходы

-   однозначно передает владение: предполагается, что отдав объект, обработчик уже не будет его модифицировать,
    что упрощает рассуждения о корректности программы

Использование классов вместо функций позволяет отвязать обработчиков друг от друга и упрощает поддержку
нескольких классов обрабатываемых объектов.

### Постановка задачи

В этой задаче вам предлагается разработать конвейер обработчиков электронных писем:

```cpp
struct Email
{
    string from;
    string to;
    string body;
};
```

Обработчики должны реализовывать абстрактный класс ```Worker```:

```cpp
class Worker
{
    public:
        virtual void Process(unique_ptr<Email> email) = 0;
        virtual void Run() {
            // только первому worker-у в пайплайне нужно реализовать этот метод
            throw logic_error("Unimplemented");
        }

    protected:
        // реализации должны вызывать PassOn, чтобы передать объект дальше
        // по цепочке обработчиков
        void PassOn(unique_ptr<Email> email) const;

    public:
        void SetNext(unique_ptr<Worker> worker);
};
```

Также реализуйте обработчики ```Reader```, ```Filter```, ```Copier``` и ```Sender```, наследующие от класса
```Worker```, а также класс ```PipelineBuilder```, конструирующий цепочку обработчиков:

```cpp
class PipelineBuilder
{
    public:
        // добавляет в качестве первого обработчика Reader
        explicit PipelineBuilder(istream& in);

        // добавляет новый обработчик Filter
        PipelineBuilder& FilterBy(Filter::Function filter);

        // добавляет новый обработчик Copier
        PipelineBuilder& CopyTo(string recipient);

        // добавляет новый обработчик Sender
        PipelineBuilder& Send(ostream& out);

        // строит цепочку с помощью метода Worker::SetNext и возвращает первый обработчик в построенной цепочке
        unique_ptr<Worker> Build();
};
```

Требования:

```Worker```

-   метод ```SetNext``` должен принимать во владение следующий обработчик из цепочки

-   метод ```PassOn``` должен вызывать метод Process следующего обработчика, если он был установлен

```Reader```

-   конструктор должен принимать входной поток ```(istream&)```, из которого нужно читать сообщения

-   метод ```Run``` должен читать из входного потока все ```e-mail```'ы и передавать дальше каждый из них.
    Один ```e-mail``` представляется во входном потоке полями ```from```, ```to```, ```body```, каждое из
    которых находится на своей строке.

```Filter```

-   конструктор должен принимать предикат типа ```function<bool(const Email&)>```

-   метод ```Process``` должен передавать дальше только сообщения, удовлетворяющие предикату

```Copier```

-   конструктор должен принимать строку-адрес получателя

-   метод ```Process``` должен передавать сообщение как исходному получателю, так и указанному в конструкторе.
    В случае, если они совпадают, дублировать сообщение не нужно

```Sender```

-   конструктор должен принимать поток для записи сообщений

-   метод ```Process``` должен записывать сообщения в поток в том же формате, в котором они были прочитаны

Все обработчики должны передавать сообщения дальше, если обратное не требуется явно.

```PipelineBuilder```

-   Конструктор должен инициализировать цепочку обработчиков обработчиком Reader с переданным потоком.

-   Методы с типом возврата ```PipelineBuilder&``` должны возвращать ссылку на экземпляр класса, для которого
    они были вызваны, а также добавлять в конец цепочки новый обработчик, соответствующий вызванному методу
    (```Filter``` для метода ```FilterBy```, ```Sender``` для метода ```Send``` и т.д.).

-   Метод ```Build``` должен возвращать готовую цепочку обработчиков; подразумевается, что после его завершения
    экземпляр ```PipelineBuilder``` больше использоваться не будет

### Заготовка решения

>   [pipeline.cpp](https://d3c33hcgiwev3.cloudfront.net/ruFJCBKuEemP8Qpm209XvA_af3227a012ae11e9a2aa7d7e33940a9b_pipeline.cpp?Expires=1648598400&Signature=Ir552JOsyII1Q0vCF~5PQFn4Wl7TGjYvllgPfD6X3J95UdPFxlalucYcyFt4Na~Ys58CUgLZP536iaKYwMzr8jgjHAyMzwtBgiNAM4ApmbzqeUDvvG~vlwNJrrdW8IsIX6NenVvAAkvMSLQeJztbvF0Pj-FBhEDwJvkualjU4tM_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)

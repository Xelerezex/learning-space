## Concurrent Map

В заготовке решения задачи «Шаблон Synchronized» мы уже слегка коснулись идеи о том, что уменьшение
размера критической секции позволяет повысить скорость работы многопоточной программы. В этой задаче
мы разовьём её больше.

Давайте представим, что у нас есть ```map```, к которому обращаются несколько потоков. Чтобы
синхронизировать доступ к нему, мы можем каждое обращение к этому ```map'у``` защитить мьютексом
(например, завернув наш map в шаблон ```Synchronized```). Теперь давайте представим, что у нас
есть ```Synchronized<map<int, int>>```, в котором хранятся все ключи от *1* до *10000*. Интуитивно
кажется, что когда из одного потока мы обращаемся к ключу *10*, а из другого — например, к ключу *6712*,
то нет смысла защищать эти обращения одним и тем же мьютексом. Это отдельные области памяти, а внутреннюю
структуру словаря мы никак не изменяем. При этом, если мы будем обращаться к ключу *6712* одновременно
из нескольких потоков, то синхронизация, несомненно, понадобится.

Отсюда возникает идея — разбить наш словарь на нескольких подсловарей с непересекающимся набором ключей
и защитить каждый из них отдельным мьютексом. Тогда при обращении разных потоков к разным ключам они
нечасто будут попадать в один и тот же подсловарь, а значит, смогут параллельно его обрабатывать. Эту
идею вам предстоит реализовать в этой задаче. Вам надо написать шаблон класса ```ConcurrentMap``` вот с
таким интерфейсом:

```cpp
template <typename K, typename V>
class ConcurrentMap {
    public:
        static_assert(is_integral_v<K>, "ConcurrentMap supports only integer keys");

        struct Access {
            V& ref_to_value;
        };

        explicit ConcurrentMap(size_t bucket_count);

        Access operator[](const K& key);

        map<K, V> BuildOrdinaryMap();
};
```

-    ```static_assert``` в начале класса говорит, что в данной задаче предполагается, что ключами
     ```ConcurrentMap```'а могут быть только целые числа.

-    Конструктор класса ```ConcurrentMap<K, V>``` принимает количество подсловарей, на которые надо
     разбить всё пространство ключей.

-    ```operator[]``` должен вести себя так же, как аналогичный оператор у map — если ключ ```key```
     присутствует в словаре, он должен возвращать объект класса ```Access```, содержащий ссылку на
     соответствующее ему значение; если же ```key``` отсутствует в словаре, в него надо добавить
     пару ```(key, V())``` и вернуть объект класса Access, содержащий ссылку на только что добавленное
     значение.

-    Структура ```Access```, должна вести себя так же, как и в шаблоне ```Synchronized```, — предоставлять
     ссылку на значение словаря и обеспечивать синхронизацию доступа к нему.

-    Метод ```BuildOrdinaryMap``` должен сливать вместе части словаря и возвращать весь словарь целиком.
     При этом он должен быть потокобезопасным, то есть корректно работать, когда другие потоки выполняют
     операции с ```ConcurrentMap```.

>   [concurrent_map.cpp](https://d3c33hcgiwev3.cloudfront.net/Lutq0iNaRPWratIjWiT1vQ_60a38f301b2e4b7db91eebbb7fc3bcf1_concurrent_map.cpp?Expires=1638489600&Signature=jo5JzLxZCehExFAgN0f5NdBZpxG10FxWWb6X6LIobfZoEBeugLRh5yGWxngainRHhspgqLYvCXp8KQgwbqtVbnu3kIbFamDFLYXEHEkWl~JEgu7riPhqvFcBwfG0v9FaIxvb4~OOGZcB9ue2sQ4NrM~MAgb~xSTFLRqdNiYFQBM_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A)
